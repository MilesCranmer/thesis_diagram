digraph mygraph {
//layout="sfdp";
overlap="prism";
splines="true";
B2 [fontsize=25 label="Experimental (injection)"];
B2 -> C4 ;
C4 [label="Pulse Creation"];
//C4 -> D7 ;
//D7 [label="Simpulse"]
C4 -> E1 ;
E1 [label="Current state"]
E1 -> F1 ;
F1 [label="Generates a Gaussian pulse for some\nspecified width and applies a given\nDM, and embeds in a single\nmatrix in the simpulse class."];
E1 -> F2 ;
F2 [label="Single-beam only"];
C4 -> D8;
D8 [label="Extensions"];
D8 -> E2 ;
E2 [label="Multi-beam"];
E2 -> F3 ;
F3 [label="Must figure out how a pulse\non the sky would map in S/N\nto each beam on telescope"];
D8 -> E3 ;
E3 [label="Additional parameters"];
E3 -> F4 ;
F4 [label="Width, spectral index, cut-off frequency"];
F5 [color="pink" style="filled" label="Generating pulses for additional transients, especially pulsars\nso can validate tests"];
F6 [color="pink" style="filled" label="Full set of ideas about generative\nneural networks to make more realistic pulses,\nessentially like linear combinations of previously recorded\nFRBs, but transformed to the given parameters\n(to recreate observed noise within the FRB\npulse shape, etc)."];
D8 -> F6;
D8 -> F5;
B2 -> C5 ;
C5 [label="Pulse Injection"];
C5 -> D9 ;
D9 [label="Current state:"];
D9 -> E5 ;
E5 [label="The simpulse class broadcasts the fake\nFRB to an L1 socket (pretending to\nbe L0)"];
E5 -> F7 ;
F7 [label="Creates the pulse on top of\na Gaussian background for the specified\nS/N."];
C5 -> D10 ;
D10 [label="Extensions:"];
D10 -> E6 ;
E6 [label="Inject on top of L0, rather\nthan generating separate data stream?"];
D10 -> E7 ;
E7 [label="On top of real data (pathfinder\nor commissioner data)."];
E7 -> F8 ;
F8 [label="This extension should be easy, as\nit would be just superimposed on the\npathfinder data instead of the background being\ngenerated"];
B2 -> C6 ;
C6 [label="L2 Monitor"];
C6 -> C61 ;
C61 [label="L2 is changing quickly, and I\nwill keep up to date by talking\nto Chitrang/others, but currently it dumps to\n/dev/stdout a list of detections, with given\nS/N, detection timeline, etc."];
C6 -> C62 ;
C62 [label="Extensions:"];
C62 -> C621 ;
C621 [label="There is no automated framework to\nconnect injected pulses to those detected. This\ncould be done easily based on injection\ntime and detection time."];
C62 -> C622 ;
C622 [label="The framework can also spit out\nstatistics rather than just the list of\ndetections, so we could potentially run batch\nruns on this data"];
B2 -> C7 ;
C7 [label="Injection->Detection Analysis"];
C7 -> C71 ;
C71 [label="Recording all detections for a particular\ngrid on parameter space, I can calculate\nthe fraction for each point in phase\nspace, and plot these with a variety\nof visualizations."];
C7 -> C72 ;
C72 [label="Make curves of minimal detectable flux\ndensity"];
C72 -> C721 ;
C721 [label="(or, contours of probability of\ndetection)"];
C72 -> C722 ;
C722 [label="for each DM, RFI environment,\netc."];
B2 -> C81;
C81 [color="pink" style="filled" label="Real-time injection analysis"];
B2 -> C82;
C82 [color="pink" style="filled" label="Gradient descent or genetic algorithms to\noptimize RFI parameters or sequence of operations\n(e.g., sum-threshold -> kurtosis -> ..., each\nwith specified threshold parameters)"];
C82 -> C821 ;
C821 [color="pink" style="filled" label="The fitness function could be a\ncombination of N_detected - N_false and total\ncompute time for the RFI pipeline"];
C82 -> C822 ;
C822 [color="pink" style="filled" label="The batch runs would be used\nto optimize the RFI pipelines to maximize\nFRB detections while minimizing false candidates"];
}
